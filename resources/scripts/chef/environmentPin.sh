#!/bin/bash

################################################################################
###        Do Not Edit - Automatically Generated by the Jenkins Job DSL
### Source: ThomasCookOnline/jenkins-jobdsl/pipelines/chef/resources/${me}
################################################################################

# use the embedded ruby that ships with chef-client
export GEM_HOME=/var/lib/jenkins/.rvm/gems/ruby-2.2.6 # hacktastic

gem install bundler

# special syntax for cookbook pins
APP_SPEC="= ${COOKBOOK_VERSION}"

# reusable function to read the current app spec pinned to the environment
knife_get_env_app_spec() {
  bundle exec knife environment show "${CHEF_ENVIRONMENT}" \
                  --attribute "cookbook_versions.${COOKBOOK_NAME}" | \
                  # take the last line
                  tail -n 1 | \
                  # take the value after the ':' char
                  cut -f 2 -d ':' | \
                  # strip the leading whitespace
                  sed 's/^ *//'
}

# reusable function to print the app spec to the build log
knife_print_env_app_spec() {
  echo "[${me}]: getting the ${CHEF_ENVIRONMENT} environment pin for ${COOKBOOK_NAME} ..."
  bundle exec knife environment show "${CHEF_ENVIRONMENT}" \
                  --attribute "cookbook_versions.${COOKBOOK_NAME}"
}

cleanup() {
  knife_print_env_app_spec

  # HACK test if we were called a second time to execute a rollback;
  #      if so, ensure we fail the build
  if [ -f "${WORKSPACE}/.converge-failure" ]; then
    echo "[${me}]: ERROR - ${CHEF_ENVIRONMENT} rollback complete; failing build ..." >&2
    rm "${WORKSPACE}/.converge-failure"
    exit 5
  fi
}
# always display the app spec pinner to the environment at ext
trap cleanup INT TERM EXIT

# HACK we call this script twice - before the converge, and after the converge
#      for a possible rollback; this if test checks to see if we are being
#      called the second time
if [ -f "${WORKSPACE}/.converge-success" ]; then
  # nothing to do, successful converge
  rm "${WORKSPACE}/.converge-success"
  exit 0
fi

# HACK test if we were called a second time to execute a rollback;
#      if so fail the build
if [ -f "${WORKSPACE}/.converge-failure" ]; then
  if [ -z "${PRIOR_APP_SPEC}" ]; then
    echo "[${me}]: ERROR - missing PRIOR_APP_SPEC environmental variable, ex. '= 1.2.3'" >&2
    echo "[${me}]: ERROR - did you directly run a job outside of the delivery pipeline?" >&2
    exit 1
  fi

  echo "[${me}]: WARN - rolling back to ${PRIOR_APP_SPEC} ... " >&2
  APP_SPEC=${PRIOR_APP_SPEC}
fi

echo "[${me}]: verifing the ${CHEF_ENVIRONMENT} environment exists..."
bundle exec knife environment show "${CHEF_ENVIRONMENT}" --attribute name >/dev/null
if [ $? -ne 0 ]; then
  echo "[${me}]: ERROR - chef environment ${CHEF_ENVIRONMENT} not found" >&2
  exit 2
fi

# update the .env.properties file to include the PRIOR_APP_SPEC
# we need to pass the value of PRIOR_APP_SPEC to the deploy.sh shell script,
# as deploy.sh may use PRIOR_APP_SPEC for rollbacks after failed converges
# default the prior app spec to empty string
echo "[${me}]: exporting the ${CHEF_ENVIRONMENT} environment pin for ${COOKBOOK_NAME} ..."
PRIOR_APP_SPEC="`knife_get_env_app_spec`"
echo "PRIOR_APP_SPEC=${PRIOR_APP_SPEC}" > "${WORKSPACE}/.env.properties"

if [ "$PRIOR_APP_SPEC" == "$APP_SPEC" ]; then
  echo "[${me}]: ${CHEF_ENVIRONMENT} environment pin for ${COOKBOOK_NAME} ${APP_SPEC} is up to date" >&2
  exit 0
fi

knife_print_env_app_spec

# update the chef environment to explicitly use this new version of the app
echo "[${me}]: setting the ${CHEF_ENVIRONMENT} environment pin for ${COOKBOOK_NAME} to ${APP_SPEC}..."
bundle exec knife exec -E "env = environments.find('name:${CHEF_ENVIRONMENT}').first; \
               env.cookbook_versions['${COOKBOOK_NAME}'] = '$APP_SPEC'; \
               env.save;"
if [ $? -ne 0 ]; then
  echo "[${me}]: ERROR - ${CHEF_ENVIRONMENT} environment update failed" >&2
  exit 4
fi

# HACK briefly wait on Chef server's SOLR indexing to index the saved APP_SPEC
sleep 1

# detect rare race conditions whereby another human or job has updated the same
# Chef environment around the same moment as our environment update;
# it's possible another process did a "dirty read" or "phantom write" between our
# `environments.find` and our `env.save` above
NEW_APP_SPEC=`knife_get_env_app_spec`
if [ "$NEW_APP_SPEC" != "$APP_SPEC" ]; then
  echo "[${me}]: ERROR - ${CHEF_ENVIRONMENT} environment update fail - dirty read or phantom write" >&2
  echo "[${me}]: ERROR - a rebuild usually corrects this condition" >&2
  exit 4
fi

exit 0
